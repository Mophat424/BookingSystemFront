// src/dashboard/AdminDashboard/ManageBookings/ManageBookings.tsx
import React, { useEffect, useState } from 'react';
import { useAppSelector, useAppDispatch } from '../../../app/store';
import { setLoading, setBookings, setError, deleteBooking } from '../../../features/bookings/bookingSlice';
import { FaEdit } from 'react-icons/fa';
import { FaTrash } from 'react-icons/fa';
import './ManageBookings.css';

// Define PublicUser interface based on auth.service.ts
interface PublicUser {
  user_id: number;
  email: string | null;
  name: string;
  role: "user" | "admin" | null;
}

const ManageBookings = () => {
  const { bookings, loading, error } = useAppSelector((state) => state.bookings);
  const dispatch = useAppDispatch();
  const { token, user } = useAppSelector((state) => state.user) as { token: string | null; user: PublicUser | null }; // Explicitly type the selector
  const role = user?.role; // Safely access role (can be null)
  const userId = user?.user_id; // Safely access user_id

  const [creating, setCreating] = useState(false);
  const [newBooking, setNewBooking] = useState({
    user_id: '',
    event_id: '',
  });

  useEffect(() => {
    const fetchBookings = async () => {
      if (!userId || !token) return; // Guard clause
      dispatch(setLoading());
      try {
        const url = role === 'admin' ? 'http://localhost:8081/bookings' : `http://localhost:8081/bookings/user/${userId}`;
        const response = await fetch(url, {
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!response.ok) {
          throw new Error('Failed to fetch bookings');
        }
        const result = await response.json();
        dispatch(setBookings(result));
      } catch (err: unknown) {
        let message = 'Network error occurred';
        if (err instanceof Error) {
          message = err.message;
        }
        dispatch(setError(message));
      }
    };
    fetchBookings();
  }, [dispatch, token, role, userId]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setNewBooking((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleCreate = async () => {
    if (!userId) return; // Guard clause
    const payload = {
      user_id: parseInt(newBooking.user_id, 10),
      event_id: parseInt(newBooking.event_id, 10),
    };
    dispatch(setLoading());
    try {
      const response = await fetch('http://localhost:8081/bookings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(payload),
      });
      if (!response.ok) throw new Error('Create failed');
      const result = await response.json();
      dispatch(setBookings([...bookings, result]));
      setCreating(false);
      setNewBooking({
        user_id: '',
        event_id: '',
      });
    } catch (err: unknown) {
      let message = 'Network error occurred';
      if (err instanceof Error) {
        message = err.message;
      }
      dispatch(setError(message));
    }
  };

  const handleDelete = async (bookingId: number) => {
    if (window.confirm('Are you sure you want to delete this booking?')) {
      dispatch(setLoading());
      try {
        const response = await fetch(`http://localhost:8081/bookings/${bookingId}`, {
          method: 'DELETE',
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!response.ok) throw new Error('Delete failed');
        await response.json();
        dispatch(deleteBooking(bookingId));
      } catch (err: unknown) {
        let message = 'Network error occurred';
        if (err instanceof Error) {
          message = err.message;
        }
        dispatch(setError(message));
      }
    }
  };

  const handleCancel = () => {
    setCreating(false);
    setNewBooking({
      user_id: '',
      event_id: '',
    });
  };

  if (loading) return <div className="loading">Loading...</div>;
  if (error) return <div className="error-message">{error}</div>;

  return (
    <div className="manage-bookings">
      <h2 className="bookings-title">Manage Bookings</h2>
      <button className="create-btn" onClick={() => setCreating(true)}>Create Booking</button>
      <table className="bookings-table">
        <thead>
          <tr>
            <th>Booking ID</th>
            <th>User ID</th>
            <th>Event ID</th>
            <th>Created At</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {creating && (
            <tr className="booking-row">
              <td></td> {/* Booking ID auto-generated by backend */}
              <td><input type="number" name="user_id" value={newBooking.user_id} onChange={handleInputChange} placeholder="User ID" className="form-input" /></td>
              <td><input type="number" name="event_id" value={newBooking.event_id} onChange={handleInputChange} placeholder="Event ID" className="form-input" /></td>
              <td></td> {/* Created At auto-generated by backend */}
              <td>
                <button className="save-btn" onClick={handleCreate}><FaEdit /></button>
                <button className="cancel-btn" onClick={handleCancel}><FaTrash /></button>
              </td>
            </tr>
          )}
          {bookings.map((booking) => (
            <tr key={booking.booking_id} className="booking-row">
              <td>{booking.booking_id}</td>
              <td>{booking.user_id}</td>
              <td>{booking.event_id}</td>
              <td>{booking.created_at}</td>
              <td>
                <button className="delete-btn" onClick={() => handleDelete(booking.booking_id)}><FaTrash /></button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default ManageBookings;